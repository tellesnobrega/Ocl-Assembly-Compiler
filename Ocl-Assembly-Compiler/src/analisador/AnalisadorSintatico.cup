import java_cup.runtime.*;

parser code {:
    
    public void report_error(String message, Object info) {
   
        StringBuffer m = new StringBuffer("Error");
   
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0) {
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(" in line "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0)                    
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", column "+(s.right+1));
            }
        }
   
	
        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

/* Terminais */
terminal 		RCOL, LCOL, RPAREN, LPAREN, RBRACKET, LBRACKET;
terminal 		XOR, OR, AND, NOT;
terminal 		EQ, GT, LT, GE, LE, NE;
terminal 		PLUS, MINUS;
terminal 		TIMES, DIV;
terminal 		BAG, SET, SEQUENCE, COLLECTION;
terminal 		PRE, POST;
terminal 		IF, THEN, ELSE, ENDIF;
terminal 		COLON, DOUBLECOLON, CONTEXT, COMMA, IMPLIES, DOT, ARROW, DOUBLEDOT, AT, PIPE, SEMICOLON; 
terminal String NAME, STRING, DOUBLE;
terminal String	TRUE, FALSE;
terminal Integer NUMBER;


/* Não terminais */
non terminal 	oclExpressions, oclExpression, constraint, contextDeclaration, contextDeclarationOpt;
non terminal 	stereotype, stereotypeName, stereotypeOpt;
non terminal	operationContext, operationName;
non terminal    formalParameterList;
non terminal    returnType, typeSpecifier, simpleTypeSpecifier, collectionType, collectionKind;
non terminal    pathName; 

non terminal 	expression, multiplicativeExpression, multiplicativeExpressionOpt, logicalExpression,           relationalExpression;
non terminal	additiveExpression, additiveExpressionOpt, ifExpression, primaryExpression;
non terminal 	postfixExpressionOpt, unaryExpression, postfixExpression, timeExpression;
non terminal 	collectionItemOpt, collectionItem, collectionItemOptTwo;
non terminal	paramOpt, relationalOperator, addOperator, logicalOperator, operator, multiplyOperator, unaryOperator;
non terminal    qualifiers, propertyCallParameters, actualParameterList, actualParameterListOpt, declarator, nameOpt, simpleTypeSpecifierOpt,  collectionItemExpressionOpt, nameOpt2;
non terminal 	propertyCall, literal, literalCollection;


/* PrecedÃªncias */
precedence left SEMICOLON, COMMA;
precedence left XOR; 
precedence left OR; 
precedence left AND; 
precedence left NOT; 
precedence left EQ, NE, GT, LT, GE, LE, IMPLIES; 
precedence left PLUS, MINUS; 
precedence left TIMES, DIV; 
precedence left DOUBLEDOT, DOUBLECOLON, COLON, DOT, ARROW;


/* Contexto */
oclExpressions ::= constraint:c oclExpressions:oclE
                   {: RESULT = new OclExpressionClass(contraint,oclE); :} 
                   | 
                   ;

constraint ::= contextDeclaration:cd stereotype:s NAME:name COLON oclExpression:oclE stereotypeOpt:sOpt 
               {: RESULT = new ConstraintClass(cd,s,name,oclE,sOpt); :}               
	    	   | 
               contextDeclaration:cd stereotype:s COLON oclExpression:oclE stereotypeOpt:sOpt 
               {: RESULT = new ConstraintClass(cd,s,oclE,sOpt); :}  
               ;

stereotypeOpt ::= stereotype:s stereotypeName:sName COLON oclExpression:oclE stereotypeOpt:sOpt 
                  {: RESULT = new StereotypeClass(s,sName,oclE,sOpt); :}
                  | 
                  ;

stereotypeName ::= NAME:name
				   {: RESULT = new StereotypeNameClass(name);; :}
				   |
                   ;

contextDeclaration ::= CONTEXT contextDeclarationOpt:cdo 
                       {: RESULT = new ContextDeclarationClass(cdo); :}
                       ;

contextDeclarationOpt ::= operationContext:opCon
						  {: RESULT = new ContextDeclarationOptClass(opCon); :};  

operationContext ::= NAME:name DOUBLECOLON operationName:opName LPAREN formalParameterList:formParList RPAREN COLON returnType:rType 
                     {: RESULT = new OperationContextClass(name,opName,formParList,rType); :}
		     		 | 
                     NAME:name DOUBLECOLON operationName:opName LPAREN formalParameterList:formParList RPAREN
		     		 {: RESULT = new OperationContextClass(name,opName,formParList); :}
                     ;

returnType ::= typeSpecifier:typeSpec
               {: RESULT = new ReturnTypeClass(typeSpec); :}
               ;

typeSpecifier ::= simpleTypeSpecifier:sTypeSpec
                  {: RESULT = new TypeSpecifierClass(sTypeSpec); :} 
                  | 
                  collectionType:colType
                  {: RESULT = new TypeSpecifierClass(colType); :} 
                  ;

simpleTypeSpecifier ::= pathName:pathName
                        {: RESULT = new SimpleTypeSpecifierClass(pathName); :} 
                        ;

pathName ::= NAME:name 
             {: RESULT = new PathNameClass(name); :} 
             | 
             pathName:pathName DOUBLECOLON NAME:name
             {: RESULT = new PathNameClass(pathName,name); :}
             ;

collectionType ::= collectionKind:colKind LPAREN simpleTypeSpecifier:sTypeSpec RPAREN
                   {: RESULT = new CollectionTypeClass(colKind,sTypeSpec); :} 
                   ;

stereotype ::= PRE:pre
               {: RESULT = new StereotypeClass("pre"); :} 
               | 
               POST:pos 
               {: RESULT = new StereotypeClass("pos"); :} 
               ;


/* ExpressÃµes */

oclExpression ::= expression:exp
                  {: RESULT = new OclExpressionClass(exp); :} 
                  ;

expression ::= logicalExpression:logExp
               {: RESULT = new ExpressionClass(logExp); :} 
               ;

collectionKind ::= BAG:bag 
                   {: RESULT = new CollectionKindClass("Bag"); :}
                   | 
                   SET:set  
                   {: RESULT = new CollectionKindClass("Set"); :}
                   |  
                   SEQUENCE:sequence 
                   {: RESULT = new CollectionKindClass("Sequence"); :}
                   | 
                   COLLECTION:collection
                   {: RESULT = new CollectionKindClass("Collection"); :}
	           	   ;

operationName ::= NAME:name 
                  {: RESULT = new OperationNameClass(name); :}
                  | 
                  EQ:eq
                  {: RESULT = new OperationNameClass("=="); :}
                  | 
                  PLUS:plus 
                  {: RESULT = new OperationNameClass("+"); :}
                  | 
                  MINUS:minus 
                  {: RESULT = new OperationNameClass("-"); :}
                  | 
                  LT:lt 
                  {: RESULT = new OperationNameClass("<"); :}
                  | 
                  LE:le 
                  {: RESULT = new OperationNameClass("<="); :}
                  | 
                  GE:ge 
                  {: RESULT = new OperationNameClass(">="); :}
                  | 
                  GT:gt 
                  {: RESULT = new OperationNameClass(">"); :}
                  | 
                  DIV:div 
                  {: RESULT = new OperationNameClass("/"); :}
                  | 
                  TIMES:times 
                  {: RESULT = new OperationNameClass("*"); :}
                  | 
                  NE:ne 
                  {: RESULT = new OperationNameClass("!="); :}
                  | 
                  IMPLIES:implies 
                  {: RESULT = new OperationNameClass("implies"); :}
                  | 
                  NOT:not
                  {: RESULT = new OperationNameClass("not"); :}
                  | 
                  XOR:xor 
                  {: RESULT = new OperationNameClass("^"); :}
                  | 
                  AND:and
                  {: RESULT = new OperationNameClass("and"); :}
                  ;

formalParameterList ::= NAME:name COLON typeSpecifier:typeSpec paramOpt:paramOpt 
						{: RESULT = new FormalParameterListClass(name,typeSpec,paramOpt); :}
                        | 
                        ;

paramOpt ::= COMMA NAME:name COLON typeSpecifier:typeSpec paramOpt:paramOpt
             {: RESULT = new ParamOptClass(name,typeSpec,paramOpt); :}
             | 
             ;

logicalExpression ::= relationalExpression:relExp
                      {: RESULT = new LogicalExpressionClass(relExp); :} 
                      |  
	              	  relationalExpression:relExp logicalOperator:logOp logicalExpression:logExp2
                      {: RESULT = new LogicalExpressionClass(relExp,logOp,relExp2); :} 
                      ;

logicalOperator ::= AND:and 
		    		{: RESULT = new LogicalOperatorClass("and"); :}
                    | 
                    OR:or 
		    		{: RESULT = new LogicalOperatorClass("or"); :}
                    | 
                    XOR:xor 
		    		{: RESULT = new LogicalOperatorClass("^"); :}
                    | 
                    IMPLIES:implies
		    		{: RESULT = new LogicalOperatorClass("implies"); :}
                    ;

relationalExpression ::= additiveExpression:addExp 
			 			 {: RESULT = new RelationalExpressionClass(addExp); :}
                         | 
                         additiveExpression:addExp1 relationalOperator:relOp additiveExpression:addExp2 
			 			 {: RESULT = new RelationalExpressionClass(addExp1,relOp,addExp2); :}
                         ;

relationalOperator ::= EQ:eq 
		       		   {: RESULT = new RelationalOperatorClass("=="); :}
                       | 
                       GT:gt
                       {: RESULT = new RelationalOperatorClass(">"); :}
                       | 
                       LT:lt
                       {: RESULT = new RelationalOperatorClass("<"); :}
                       | 
                       GE:ge
                       {: RESULT = new RelationalOperatorClass(">="); :}
                       | 
                       LE:le
                       {: RESULT = new RelationalOperatorClass("<="); :}
                       |
                       NE:ne
                       {: RESULT = new RelationalOperatorClass("!="); :}
                       ;

additiveExpression ::= multiplicativeExpression:multExp additiveExpressionOpt:addExpOpt
		       		   {: RESULT = new AdditiveExpressionClass(multExp,addExpOpt); :}
                       ;

additiveExpressionOpt ::= additiveExpressionOpt:addExpOpt addOperator:addOp multiplicativeExpression:multExp 
                          {: RESULT = new AdditiveExpressionOptClass(addExpOpt,addOp,multExp); :}
                          | 
                          ;

addOperator ::= PLUS:plus
                {: RESULT = new AddOperatorClass("+"); :} 
                | 
                MINUS:minus
                {: RESULT = new AddOperatorClass("-"); :} 
                ;

multiplicativeExpression ::= unaryExpression:uExp multiplicativeExpressionOpt:multExpOpt
			     			 {: RESULT = new MultiplicativeExpressionClass(uExp,multExpOpt); :}
                             ;

multiplicativeExpressionOpt ::= multiplicativeExpressionOpt:multExpOpt multiplyOperator:multOp unaryExpression:uExp 
 			        			{: RESULT = new MultiplicativeExpressionOptClass(multExpOpt,multOp,uExp); :}
                                | 
                                ;

unaryExpression ::= unaryOperator:uOp postfixExpression:postExp 
                    {: RESULT = new UnaryExpressionClass(uOp,postExp); :}
                    | 
                    postfixExpression:postExp 
                    {: RESULT = new UnaryExpressionClass(postExp); :}
                    ;

unaryOperator ::= MINUS:minus 
		  		  {: RESULT = new UnaryOperatorClass("-"); :}
                  | 
                  NOT:not
		  		  {: RESULT = new UnaryOperatorClass("not"); :}
                  ;

multiplyOperator ::= TIMES:times
		     		 {: RESULT = new MultiplyOperatorClass("*"); :}
                     | 
                     DIV:div
		     		 {: RESULT = new MultiplyOperatorClass("*"); :}
                     ;

postfixExpression ::= primaryExpression:priExp postfixExpressionOpt:postExpOpt
				      {: RESULT = new PostFixExpressionClass(priExp,postExpOpt); :}
                      ;

postfixExpressionOpt ::= postfixExpressionOpt:postExpOpt operator:op propertyCall:proCall 
			 			 {: RESULT = new PostFixExpressionOptClass(postExpOpt,op,proCall); :}
                         | 
                         ;

operator ::= DOT:dot 
             {: RESULT = new OperatorClass("dot"); :}
             | 
             ARROW:arrow
             {: RESULT = new OperatorClass("arrow"); :}
             ;

primaryExpression ::= literalCollection:litCol 
                      {: RESULT = new PrimaryExpressionClass(litCol); :}
                      | 
                      literal:lit 
                      {: RESULT = new PrimaryExpressionClass(lit); :}
                      | 
                      propertyCall:propCall 
                      {: RESULT = new PrimaryExpressionClass(propCall); :}
                      | 
                      LPAREN expression:exp RPAREN 
                      {: RESULT = new PrimaryExpressionClass(exp); :}
                      | 
                      ifExpression:ifExp
                      {: RESULT = new PrimaryExpressionClass(ifExp); :}
                      ;

literalCollection ::= collectionKind:colKind LBRACKET collectionItemOpt:colItemOpt RBRACKET
                      {: RESULT = new LiteralCollectionClass(colKind,colItemOpt); :}
                      ;

collectionItemOpt ::= collectionItem:colItem1 collectionItemOptTwo:colItemOpt
                      {: RESULT = new CollectionItemClass(colItem,colItemOpt); :} 
                      | 
                      ;

collectionItemOptTwo ::= collectionItemOptTwo:colItemOpt COMMA collectionItem:colItem 
                         {: RESULT = new CollectionItemOptTwoClass(colItemOpt,colItem); :}
                         | 
                         ;

collectionItem ::= expression:exp collectionItemExpressionOpt:colItemExpOpt 
		   		   {: RESULT = new CollectionItemClass(exp,colItemExpOpt); :}
                   ;

collectionItemExpressionOpt ::= DOUBLEDOT expression:exp 
								{: RESULT = new CollectionItemExpressionOptClass(exp); :}
                                |
                                ;

literal ::= STRING:string
            {: RESULT = new LiteralClass("string"); :}
            | 
            NUMBER:number 
            {: RESULT = new LiteralClass("number"); :}
            |
            DOUBLE:double
            {: RESULT = new LiteralClass("double"); :}
            ;
            

propertyCall ::= pathName:pathName timeExpression:timeExp qualifiers:qual propertyCallParameters:propCallParam 
		 {: RESULT = new PropertyCallClass(pathName,timeExp,qual,propCallParam); :}
                 | 
                 pathName:pathName timeExpression:timeExp qualifiers:qual  
		 {: RESULT = new PropertyCallClass(pathName,timeExp,qual); :}
                 | 
                 pathName:pathName timeExpression:timeExp propertyCallParameters:propCallParam 
		 {: RESULT = new PropertyCallClass(pathName,timeExp,propCallParam); :}
                 | 
                 pathName:pathName timeExpression:timeExp 
		 {: RESULT = new PropertyCallClass(pathName,timeExp); :}
                 | 
                 pathName:pathName qualifiers:qual propertyCallParameters:propCallParam 
		 {: System.out.println("Property Call"); :}
                 |
                 pathName:pathName qualifiers:qual
		 {: RESULT = new PropertyCallClass(pathName,qual); :}
                 | 
                 pathName:pathName propertyCallParameters:propCallParam 
		 {: RESULT = new PropertyCallClass(pathName,propCallParam); :}
                 |
                 pathName:pathName
		 {: RESULT = new PropertyCallClass(pathName); :}
                 ;

timeExpression ::= AT PRE
		   {: RESULT = new TimeExpressionClass(); :}
                   ;

qualifiers ::= LCOL actualParameterList:actualParamList RCOL
	       	   {: RESULT = new QualifiersClass(actualParamList); :}
               ;

actualParameterList ::= expression:exp actualParameterListOpt:actualParamListOpt
            	        {: RESULT = new ActualParameterListClass(exp,actualParamListOpt); :}
                        ;

actualParameterListOpt ::= COMMA expression:exp actualParameterListOpt:actualParamListOpt 
	                   {: RESULT = new ActualParameterListOptClass(exp,actualParamListOpt); :}
                           | 
                           ;

propertyCallParametersClass ::= LPAREN declarator:dec actualParameterList:actualParamList RPAREN 
                           {: RESULT = new PropertyCallParametersClass(dec,atualParamList); :}
                           | 
                           LPAREN actualParameterList:actualParamList RPAREN 
                           {: RESULT = new PropertyCallParametersClass(atualParamList); :}
                           |
                           LPAREN declarator:dec RPAREN 
                           {: RESULT = new PropertyCallParametersClass(dec); :}
                           | 
                           LPAREN RPAREN
                           {: RESULT = new PropertyCallParametersClass(); :}
                           ;

declarator ::= NAME:name nameOpt:nameOpt simpleTypeSpecifierOpt:sTypeSpecOpt SEMICOLON NAME:name2 COLON typeSpecifier:typeSpec EQ expression:exp PIPE 
               {: RESULT = new DeclaratorClass(name,nameOpt,sTypeSpecOpt,name2,typeSpec,exp); :}
               | 
               NAME:name nameOpt:nameOpt simpleTypeSpecifierOpt:sTypeSpecOpt PIPE 
               {: RESULT = new DeclaratorClass(name,nameOpt,sTypeSpecOpt); :}
               ;

nameOpt ::= NAME:name nameOpt:nameOpt 
            {: RESULT = new NameOptClass(name,nameOpt); :}
            | 
            nameOpt2:nameOpt2
            {: RESULT = new NameOptClass(nameOpt2); :}
            ;

nameOpt2 ::=  COMMA NAME:name 
              {: RESULT = new NameOpt2Class(name); :}
              | 
              ;

simpleTypeSpecifierOpt ::= COLON simpleTypeSpecifier:sTypeSpecOpt 
                           {: RESULT = new SimpleTypeSpecifierOptClass(sTypeSpecOpt); :}
                           | 
                           ;

ifExpression ::= IF expression:exp THEN expression:exp ELSE expression:exp ENDIF
                 {: RESULT = new IfExpressionClass(exp,exp,exp); :}
                 ;

boolean	::= TRUE:t
			{: RESULT = new BooleanClass("True"); :}
			| FALSE:f
			{: RESULT = new BooleanClass("False"); :};             
			
number	::= DOUBLE:d
		    {:RESULT = new NumberClass(d, "Double"); :} 
			| INTEGER :i
			{: RESULT = new NumberClass(i, "Integer"); :};    