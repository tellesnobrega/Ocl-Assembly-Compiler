import java_cup.runtime.*;

parser code {:
    
    public void report_error(String message, Object info) {
   
        StringBuffer m = new StringBuffer("Error");
   
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0) {
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(" in line "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0)                    
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", column "+(s.right+1));
            }
        }
   
	
        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

/* Terminais */
terminal 		RCOL, LCOL, RPAREN, LPAREN, RBRACKET, LBRACKET;
terminal 		XOR, OR, AND, NOT;
terminal 		EQ, GT, LT, GE, LE, NE;
terminal 		PLUS, MINUS;
terminal 		TIMES, DIV;
terminal 		BAG, SET, SEQUENCE, COLLECTION;
terminal 		PRE, POST;
terminal 		IF, THEN, ELSE, ENDIF;
terminal 		COLON, DOUBLECOLON, CONTEXT, COMMA, IMPLIES, DOT, ARROW, DOUBLEDOT, AT, PIPE, SEMICOLON; 
terminal String NAME, STRING, DOUBLE;
terminal String	TRUE, FALSE;
terminal Integer NUMBER;


/* Não terminais */
non terminal 	oclExpressions, oclExpression, constraint, contextDeclaration, contextDeclarationOpt;
non terminal 	stereotype, stereotypeName, stereotypeOpt;
non terminal	operationContext, operationName;
non terminal    formalParameterList;
non terminal    returnType, typeSpecifier, simpleTypeSpecifier, collectionType, collectionKind;
non terminal    pathName; 

non terminal 	expression, multiplicativeExpression, multiplicativeExpressionOpt, logicalExpression,           relationalExpression;
non terminal	additiveExpression, additiveExpressionOpt, ifExpression, primaryExpression;
non terminal 	postfixExpressionOpt, unaryExpression, postfixExpression, timeExpression;
non terminal 	collectionItemOpt, collectionItem, collectionItemOptTwo;
non terminal	paramOpt, relationalOperator, addOperator, logicalOperator, operator, multiplyOperator, unaryOperator;
non terminal    qualifiers, propertyCallParameters, actualParameterList, actualParameterListOpt, declarator, nameOpt, simpleTypeSpecifierOpt,  collectionItemExpressionOpt, nameOpt2;
non terminal 	propertyCall, literal, literalCollection;


/* PrecedÃªncias */
precedence left SEMICOLON, COMMA;
precedence left XOR; 
precedence left OR; 
precedence left AND; 
precedence left NOT; 
precedence left EQ, NE, GT, LT, GE, LE, IMPLIES; 
precedence left PLUS, MINUS; 
precedence left TIMES, DIV; 
precedence left DOUBLEDOT, DOUBLECOLON, COLON, DOT, ARROW;


/* Contexto */
oclExpressions ::= constraint oclExpressions 
                   {: System.out.println("Ocl Expressions"); :} 
                   | 
                   ;

constraint ::= contextDeclaration stereotype NAME COLON oclExpression stereotypeOpt 
               {: System.out.println("Constraint"); :}               
	       | 
               contextDeclaration stereotype COLON oclExpression stereotypeOpt 
               {: System.out.println("Constraint"); :}  
               ;

stereotypeOpt ::= stereotype stereotypeName COLON oclExpression stereotypeOpt 
                  {: System.out.println("Stereotype Opt"); :}
                  | 
                  ;

stereotypeName ::= NAME 
		   {: System.out.println("Stereotype Name"); :}
                   | 
                   ;

contextDeclaration ::= CONTEXT contextDeclarationOpt 
                       {: System.out.println("\nComecando uma derivacao: \nContext Declaration"); :}
                       ;

contextDeclarationOpt ::= operationContext 
			  {: System.out.println("Context Declaration Opt"); :};  

operationContext ::= NAME DOUBLECOLON operationName LPAREN formalParameterList RPAREN COLON returnType 
                     {: System.out.println("Operation Context"); :}
		     | 
                     NAME DOUBLECOLON operationName LPAREN formalParameterList RPAREN
		     {: System.out.println("Operation Context"); :}
                     ;

returnType ::= typeSpecifier
               {: System.out.println("Return Type"); :}
               ;

typeSpecifier ::= simpleTypeSpecifier
                  {: System.out.println("Type Specifier"); :} 
                  | 
                  collectionType
                  {: System.out.println("Type Specifier"); :} 
                  ;

simpleTypeSpecifier ::= pathName
                        {: System.out.println("Simple Type Specifier"); :} 
                        ;

pathName ::= NAME 
             {: System.out.println("Path Name"); :} 
             | 
             pathName DOUBLECOLON NAME
             ;

collectionType ::= collectionKind LPAREN simpleTypeSpecifier RPAREN
                   {: System.out.println("Collection Type"); :} 
                   ;

stereotype ::= PRE 
               {: System.out.println("StereoType"); :} 
               | 
               POST 
               {: System.out.println("StereoType"); :} 
               ;


/* ExpressÃµes */

oclExpression ::= expression
                  {: System.out.println("OCL Expression"); :} 
                  ;

expression ::= logicalExpression
               {: System.out.println("Expression"); :} 
               ;

collectionKind ::= BAG 
                   {: System.out.println("Collection Kind"); :}
                   | 
                   SET  
                   {: System.out.println("Collection Kind"); :}
                   |  
                   SEQUENCE 
                   {: System.out.println("Collection Kind"); :}
                   | 
                   COLLECTION
                   {: System.out.println("Collection Kind"); :}
	           ;

operationName ::= NAME 
                  {: System.out.println("Operation Name"); :}
                  | 
                  EQ 
                  {: System.out.println("Operation Name"); :}
                  | 
                  PLUS 
                  {: System.out.println("Operation Name"); :}
                  | 
                  MINUS 
                  {: System.out.println("Operation Name"); :}
                  | 
                  LT 
                  {: System.out.println("Operation Name"); :}
                  | 
                  LE 
                  {: System.out.println("Operation Name"); :}
                  | 
                  GE 
                  {: System.out.println("Operation Name"); :}
                  | 
                  GT 
                  {: System.out.println("Operation Name"); :}
                  | 
                  DIV 
                  {: System.out.println("Operation Name"); :}
                  | 
                  TIMES 
                  {: System.out.println("Operation Name"); :}
                  | 
                  NE 
                  {: System.out.println("Operation Name"); :}
                  | 
                  IMPLIES 
                  {: System.out.println("Operation Name"); :}
                  | 
                  NOT 
                  {: System.out.println("Operation Name"); :}
                  | 
                  XOR 
                  {: System.out.println("Operation Name"); :}
                  | 
                  AND
                  {: System.out.println("Operation Name"); :}
                  ;

formalParameterList ::= NAME COLON typeSpecifier paramOpt 
			{: System.out.println("Formal Parameter List"); :}
                        | 
                        ;

paramOpt ::= COMMA NAME COLON typeSpecifier paramOpt
             {: System.out.println("Param Opt"); :}
             | 
             ;

logicalExpression ::= relationalExpression
                      {: System.out.println("Logical Expression"); :} 
                      |  
	              relationalExpression logicalOperator logicalExpression
                      {: System.out.println("Logical Expression"); :} 
                      ;

logicalOperator ::= AND 
		    {: System.out.println("Logical Operator"); :}
                    | 
                    OR 
		    {: System.out.println("Logical Operator"); :}
                    | 
                    XOR 
		    {: System.out.println("Logical Operator"); :}
                    | 
                    IMPLIES 
		    {: System.out.println("Logical Operator"); :}
                    ;

relationalExpression ::= additiveExpression 
			 {: System.out.println("Relational Expression"); :}
                         | 
                         additiveExpression relationalOperator additiveExpression 
			 {: System.out.println("Relational Expression"); :}
                         ;

relationalOperator ::= EQ 
		       {: System.out.println("Relational Operator"); :}
                       | 
                       GT 
		       {: System.out.println("Relational Operator"); :}
                       | 
                       LT 
		       {: System.out.println("Relational Operator"); :}
                       | 
                       GE 
		       {: System.out.println("Relational Operator"); :}
                       | 
                       LE 
		       {: System.out.println("Relational Operator"); :}
                       | 
                       NE
		       {: System.out.println("Relational Operator"); :}
                       ;

additiveExpression ::= multiplicativeExpression additiveExpressionOpt
		       {: System.out.println("Additive Expression"); :}
                       ;

additiveExpressionOpt ::= additiveExpressionOpt addOperator multiplicativeExpression 
                          {: System.out.println("Additive Expression Opt"); :}
                          | 
                          ;

addOperator ::= PLUS
                {: System.out.println("Add Operator"); :} 
                | 
                MINUS
                {: System.out.println("Add Operator"); :} 
                ;

multiplicativeExpression ::= unaryExpression multiplicativeExpressionOpt
			     {: System.out.println("Multiplicative Expression"); :}
                             ;

multiplicativeExpressionOpt ::= multiplicativeExpressionOpt multiplyOperator unaryExpression 
 			        {: System.out.println("Multiplicative Expression Opt"); :}
                                | 
                                ;

unaryExpression ::= unaryOperator postfixExpression 
                    {: System.out.println("Unary Expression"); :}
                    | 
                    postfixExpression 
                    {: System.out.println("Unary Expression"); :}
                    ;

unaryOperator ::= MINUS 
		  {: System.out.println("Unary Operator"); :}
                  | 
                  NOT
		  {: System.out.println("Unary Operator"); :}
                  ;

multiplyOperator ::= TIMES 
		     {: System.out.println("Multiply Operator"); :}
                     | 
                     DIV
		     {: System.out.println("Multiply Operator"); :}
                     ;

postfixExpression ::= primaryExpression postfixExpressionOpt
		      {: System.out.println("Postfix Expression"); :}
                      ;

postfixExpressionOpt ::= postfixExpressionOpt operator propertyCall 
			 {: System.out.println("Postfix Expression Opt"); :}
                         | 
                         ;

operator ::= DOT 
             {: System.out.println("Operator"); :}
             | 
             ARROW
             {: System.out.println("Operator"); :}
             ;

primaryExpression ::= literalCollection 
                      {: System.out.println("Primary Expression"); :}
                      | 
                      literal 
                      {: System.out.println("Primary Expression"); :}
                      | 
                      propertyCall 
                      {: System.out.println("Primary Expression"); :}
                      | 
                      LPAREN expression RPAREN 
                      {: System.out.println("Primary Expression"); :}
                      | 
                      ifExpression
                      {: System.out.println("Primary Expression"); :}
                      ;

literalCollection ::= collectionKind LBRACKET collectionItemOpt RBRACKET
                      {: System.out.println("Literal Collection"); :}
                      ;

collectionItemOpt ::= collectionItem collectionItemOptTwo
                      {: System.out.println("Collection Item Opt"); :} 
                      | 
                      ;

collectionItemOptTwo ::= collectionItemOptTwo COMMA collectionItem 
                         {: System.out.println("Collection Item Opt Two"); :}
                         | 
                         ;

collectionItem ::= expression collectionItemExpressionOpt 
		   {: System.out.println("Collection Item"); :}
                   ;

collectionItemExpressionOpt ::= DOUBLEDOT expression 
				{: System.out.println("Collection Item Expression Opt"); :}
                                |
                                ;

literal ::= STRING 
            {: System.out.println("Literal"); :}
            | 
            NUMBER 
            {: System.out.println("Literal"); :}
            |
            DOUBLE
            {: System.out.println("Literal"); :}
            ;
            

propertyCall ::= pathName timeExpression qualifiers propertyCallParameters 
		 {: System.out.println("Property Call"); :}
                 | 
                 pathName timeExpression qualifiers  
		 {: System.out.println("Property Call"); :}
                 | 
                 pathName timeExpression propertyCallParameters 
		 {: System.out.println("Property Call"); :}
                 | 
                 pathName timeExpression 
		 {: System.out.println("Property Call"); :}
                 | 
                 pathName qualifiers propertyCallParameters 
		 {: System.out.println("Property Call"); :}
                 |
                 pathName qualifiers
		 {: System.out.println("Property Call"); :}
                 | 
                 pathName propertyCallParameters 
		 {: System.out.println("Property Call"); :}
                 |
                 pathName
		 {: System.out.println("Property Call"); :}
                 ;

timeExpression ::= AT PRE
		   {: System.out.println("Time Expression"); :}
                   ;

qualifiers ::= LCOL actualParameterList RCOL
	       {: System.out.println("Qualifiers"); :}
               ;

actualParameterList ::= expression actualParameterListOpt
            	        {: System.out.println("Actual Parameter List"); :}
                        ;

actualParameterListOpt ::= COMMA expression actualParameterListOpt 
	                   {: System.out.println("Actual Parameter List Opt"); :}
                           | 
                           ;

propertyCallParameters ::= LPAREN declarator actualParameterList RPAREN 
                           {: System.out.println("Property Call Parameters"); :}
                           | 
                           LPAREN actualParameterList RPAREN 
                           {: System.out.println("Property Call Parameters"); :}
                           |
			   LPAREN declarator RPAREN 
                           {: System.out.println("Property Call Parameters"); :}
                           | 
                           LPAREN RPAREN
                           {: System.out.println("Property Call Parameters"); :}
                           ;

declarator ::= NAME nameOpt simpleTypeSpecifierOpt SEMICOLON NAME COLON typeSpecifier EQ expression PIPE 
               {: System.out.println("Declarator"); :}
               | 
               NAME nameOpt simpleTypeSpecifierOpt PIPE 
               {: System.out.println("Declarator"); :}
               ;

nameOpt ::= NAME nameOpt 
            {: System.out.println("Name Opt"); :}
            | 
            nameOpt2
            {: System.out.println("Name Opt"); :}
            ;

nameOpt2 ::=  COMMA NAME 
              {: System.out.println("Name Opt Two"); :}
              | 
              ;

simpleTypeSpecifierOpt ::= COLON simpleTypeSpecifier 
                           {: System.out.println("Simple Type Specifier Opt"); :}
                           | 
                           ;

ifExpression ::= IF expression THEN expression ELSE expression ENDIF
                 {: System.out.println("If Expression"); :}
                 ;



